A. Account of lined output:

Order: number of output line, parent or child, line number from C code, value of
forkret

1. P, 16, forkret = 0 (not set yet)
2. P, 23, forkret = 101
3. C, 19, forkret = 0          // Race condition 
4. P, 8, forkret = 101 
5. C, 8, forkret = 0
6. C, 10, forkret = 0
7. P, 26, forkert = 101 



B. 

1. P, 16, forkret = 0
2. P, 23, forkret = 101
3. C, 19, forkret = 0 
4. C, 8, forkret = 0
5. C, 10, forkret = 0 
6. P, 26, forkret = 101

After the fork(), the race condition arises because the parent and child processes
execute independently and both send signals (SIGURSR1) to each other. In Part A, 
line 20 (kill(getppid(), SIGUSR1)) is the child sending a signal to the parent, 
and the parent handles the child's signal first, and the waits for the child to 
terminate. But in part B, the parent sends a signal to the child, and the child 
handles the parent's signal first. It enters the handler1() function and terminates
before the parent handles the child's signal.

So the steps are Child: kill(getppid(), SIGUSR1) and Parent: kill(forkret, SIGUSR1)



C. 

1. P, 16, forkret = 0 
2. P, 23, forkret = 101     // Child handles parent's signal 
3. C, 8, forkret = 0 
4. C, 10, forkret = 0 
5. P, 26, forkret = 101 

This race condition occurs also due to the independence between the parent and 
child processes. The parent first prints out its child, then it sends a signal to
the child (Line 24: kill(forkret, SIGUSR1)). This happens before the child even 
has a chance to print out its statement on line 19. The child immediately handles 
the signal, enters handler1(), prints (101) handler 1 and (101) seeya, then terminates
before sending its signal to the parent. Then the parent prints out done. 

The lines in competition are line 20 (child sending a signal to the parent) and 
line 24 (parent sending a signal to the child). In this case, the child handles 
the parent's signal before it has a chance to execute its own print statement.



D. 

1. P, 16, forkret = 0 
2. C, 19, forkret = 0
3. P, 8, forkret = 101 
4. P, 10, forkret = 101 


The race condition lies between the child's signal delivery on line 20 
(kill(getppid(), SIGUSR1)) and the parent's forkret assignment (forkret = fork())
on line 18. In the parent, fork() returns the child's PID (101 here), but this 
value has not been assigned in forkret yet because the parent hasn't reached 
line 18. Before the parent updates this value, the child sends a signal to the 
parent using kill(getppid(), SIGURSR1) in line 20. This in turn causes the parent 
to immediately handle the signal and enters handler1(). This leads to our output 
in line 3. In the parent's handler1(), though, forkret is still 0 because it has
not been updated yet. As a result, the !forkret efvaluates to true, prints (100)
handler1 and (100) seeya and terminates the parent process prematurely. 
