(Q1) 
A. incq %rsi;                   Destination: %rsi       Value: 0x9 
B. xorq %rbx, %rbx;             Destination: %rbx       Value: 0x0
C. decq (%rax)                  Destination: 0x210      Value: 0xAA
D. subq 0x228, %rdi             Destination: %rdi       Value: 0xBE
E. notq %rdx                    Destination: %rdx       Value: 0xFFFFFFFFFFFFFFFE
F. shlq %rsi, (%rcx)            Destination: 0x220      Value: 0x900
G. subq $0x100, %rax            Destination: %rax       Value: 0x110
H. imulq %rdi, (%rax, %rsi)     Destination: 0x218      Value: 0xBC00
I. orq (%rcx), %rax             Destination: %rax       Value: 0x219
J. shrq %rdx, (%rdi, %rsi, 38)  Destination: 0x230      Value: 0x2a


*For D, 0x100 - 0x228 = -296 (decimal). Convert to hexadecimal = 0x128. 
Using 16 bit. 0xFFFF - 0x128 + 1 = 0xFED7 + 1 = 0xFED8
*For E, we invert the 64-bit 0x0000000000000001, we get: 0xFFFFFFFFFFFFFFFE
*For F, we shit value of 0x220, 0x09, left by 8 bits. Each hexa digit is 4 bits. 
So we shift by 2. 
*For H, we add rax and rsi to get 0x218, multiply the value 0xBC by 100
*For J, shift 0x100 + 0x8 * 0x26 = 0x100 + 0x130 = 0x230. Shift 0x54 by 1 right



(Q2)
A. Which registers hold program values x, n, result, and mask? 
x: %rdi    (Line 8)
n: %rsi   (Line 10)
result: %rax   (Line 3)
mask: %rdx   (Line 4)

B. What are the initial values of result and mask?
result = 0, mask = 4 

C. What is the test condition for mask?
Test if mask != 0. (Line 11).
If mask is equal to zero, jump out of the loop. If it is not equal to zero 
(Line 12 jne), we jump back to foo and re-execute the loop.

D. How does mask get updated?
In Line 10, shlq. Mask is updated when a left shift operation by rsi (n) units
is performed. 

E. How does result get updated?
In Line 9, an orq operation is used. The result is updated after going through 
an OR with the outcome of (x & mask). 
result = result | (x & mask);


F. Full Code:
long loop(long x, long n) { 
    long result = 0; 
    long mask; 
    for (mask = 4; mask != 0; mask = mask << n){ 
        result = result | (x & mask);
    }
    return result; 
}

long loop(long x, long n) {
long result = ___1___;
long mask;
for (mask = ___2___; mask ___3___; mask = ___4___) {
       result ___5___;
     }
return result; }

___1___: 0
___2___: 4
___3___: != 0
___4___: mask << n
___5___: = result | (x & mask)



(Q3) 
long funcQ(long x, long y) { 
    return x + 3 * y;
}
long funcP(long r, long s, long t) { 
    if (s <= 0) {
        return funcQ(s, r) + t; 
    }
    else {
        return r + funcQ(r, t); 
    }
}