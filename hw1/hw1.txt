(Q1)
foo = 1
endian = !(*(char*)&foo) 

This code determines the endianness of the machine by assigning `foo` to `1` 
(binary: `00000000 00000000 00000000 00000001`) and casting its address to a 
`char*`, which allows us to access only the first byte in memory (lowest
memory address). Later, by dereferencing `(char*)&foo`, we read the value of 
the lowest byte. On a little-endian machine, the least significant
byte is stored first, so this byte will be `1`. On a big-endian 
 machine, the most significant byte is stored first, so the first byte will be
  `0`. 
Due to ternary conditional rules, we use ! to invert the results.



(Q2)
A. (%rcx)  
    Value: 0x09    
    Mode: Indirect

B. 0x12 (%rax) 
    Value: Unknown
    Mode: Base + Displacement 
    The value would have been M[IMM + R[rb]], which is 0x12 + 0x210 = 0x222.
    However, the address is not listed on the table, and we also do not 
    know the endianness. It is between 0x220 and 0x228, but we cannot tell
    which value it could be. 

C. 560 
    Value: 0x54     (Reason: hexa is 0x230) 
    Mode: Absolute

D. (%rax, %rsi) 
    Value: 0xBC    (Reason: 0x210 + 0x8)
    Mode: Indexed 

E. 0x108 (%rdi, %rdx, 0x20)
    Value: 0x42     (Reason: 0x108 + 0x100 + 0x1 * 20)
    Mode: Scale Indexed 

F. $250
    Value: 0xFA     (250 = 0xFA)
    Mode: Immediate

G. 0x08(,%rsi,0x45)
    Value: 0x54
    Mode: Scale Indexed